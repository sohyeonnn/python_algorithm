#DP
'''
#DP = 동적 계획법;
: '동적'의 의미
- 일반적인 프로그래밍 분야에서의 동적(Dynamic)의 의미
=> 자료구조에서 동적 할당(Dynamic Allocation)은 프로그램이 실행되는 도중에
실행에 필요한 메모리를 할당하는 기법을 의미한다.
=> 반면, DP에서의 'dynamic'은 별다른 의미 없이 사용된 단어이다.


#DP(Dynamic Programming, 동적 계획법)
- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
- 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
=> 즉, 한번 계산해서 해결한 문제는 되돌아가지 않도록 한다.

- 구현은 두 가지 방식으로 구성; 탑다운(하향식)/바텀업(상향식)
- DP는 문제가 특정 조건을 만족할 때 사용할 수 있다.
    1. 최적 부분 구조(Optimal Substructure)
    : 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
    2. 중복되는 부분 문제(Overlapping Subproblem)
    : 동일한 작은 문제를 반복적으로 해결해야 한다.


(case1)단순재귀 피보나치 수열
- 대표적인 DP 예제
- 실제로 프로그램 상에서 표현하고자할 때는 배열, 리스트를 이용해 나타낸다.
- 시간 복잡도; O(2**N)
- 시간 복잡도 분석;
=> 단순 재귀 함수로 해결하게되면 지수 시간 복잡도를 가지게 된다.
=> 즉, 같은 부분이 여러번 호출되게 되고
    => 수행시간 측면에서 매우 비효율적으로 동작하게된다.(중복되는 부분 문제)

(case2)다이나믹 프로그래밍 피보나치 수열
- 최적 부분 구조, 중복되는 부분 문제의 조건을 만족함


#메모이제이션(Memoization, 탑다운, 하향식방법)
- DP를 구현하는 방법 중 하나
- 한 번 계산한 결과를 메모리 공간에 메모하는 기법이다.
=> 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
=> 별도의 테이블(=배열)에 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 한다.


#탑다운 vs 바텀업

1. 탑다운 = 하향식
- 구현 과정에서 재귀함수를 이용
- 즉, 큰 문제를 해결하기 위해 작은 문제를 해결하고 그 작은 문제가 모두 해결되면
 큰 문제에 대한 답까지 얻을 수 있도록 코드를 작성한다.
    *이 과정에서 한번 계산된 결과값을 저장하기 위해 메모이제이션 기법을 사용한다

2. 바텀업 = 상향식
- 단순 반복문(for문)을 이용
- 아래쪽에서 부터 작은 문제를 하나씩 해결해 나가면서 먼저 계산했던 값을 활용하여
 그 다음의 문제까지 차례대로 해결한다.
    **DP의 전형적인 형태는 바텀업 방식을 사용한다.
    (결과 저장용 리스트는 DP테이블 이라고 부른다.)


* 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미한다.
=> 즉, DP에 국한된 개념이 아니며 한 번 계산된 결과를 담아 놓기만 하고 DP를 위해 활용하지 않을 수도 있다.


#다이나믹 프로그래밍 vs 분할 정복(quick 정렬)
- DP와 분할정복은 모두 '최적 부분 구조'를 가질 때 사용할 수 있다.
=> 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황

- DP와 분할정복의 차이점은 '부분 문제의 중복'이다.
=> DP는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복된다.
=> 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 x


#DP문제 접근 방법
- 주어진 문제가 DP유형임을 파악하는 것이 중요하다
- 먼저 그리디, 구현, 브루트포스 등의 알고리즘으로 해결할 수 있는지를 검토해본다.
    => 다른 알고리즘으로 해결 방법이 떠오르지 않는다면 DP알고리즘을 고려한다.

- 어떠한 문제를 풀때 우선 재귀함수를 이용하여 비효울적인 완전탐색 프로그램을 작성한 뒤에
(탑다운) 작은 문제에서 구한 답이 큰 문제로 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있다.
'''



#피보나치 수열(단순 재귀)
'''
def fibo(x):
    if x == 1 or x == 2:    #첫번째 or 두번째 피보나치 수를 호출할 때 1을 return하게 만든다(이 지점에서 함수가 종료될 수 있도록 명시해주는 것)
        return 1
    return fibo(x-1) + fibo(x-2)    #바로 앞에 있는 피보나치 수와 두 칸 앞에 있는 피보나치 수를 더한 값이 현재의 피보나치 수
print(fibo(4))
'''


#피보나치 수열(탑다운 DP)
'''
d = [0]*100     #메모이제이션을 하기위한 리스트 초기화(0~피보99까지 구하기때문에 100개의 0을 초기화해줌)

def fibo(x):
    if x == 1 or x == 2:
        return 1

    if d[x] != 0:       #이미 계산한 적 있는 문제라면 값을 그대로 반환
        return d[x]

    else:       #아니라면 피보나치 계산한 값을 반환
        d[x] = fibo(x-1) + fibo(x-2)
        return d[x]

print(fibo(99))
'''


#피보나치 수열(바텀업 DP)
'''
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]      #피보나치 점화식으로 각각의 항에대한 값을 구한다.

#즉 작은 문제부터 해결해 놓은 다음에, 해결해 놓은 작은 문제들을 조합해서 앞으로의 큰 문제들을 차례대로 구해 나가는 것
print(d[n])
'''