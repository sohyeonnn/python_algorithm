## 1. 인접 행렬

그래프의 연결 관계를 행렬로 표현하여 이차원 배열로 나타내는 방식

```buildoutcfg
graph[i][j]: 노드 i에서 j로 가는 간선이 존재할 경우 1, 존재하지 않을 경우 0
```
* 만일 표현하고자 하는 그래프가 방향이 없는 무향 그래프인 경우, 노드 i 에서 노드 j 로 가는 길이 존재하면, 노드 j 에서 노드 i 로 가는 길 또한 존재한다.

* 인접행렬 구현
```python
#양방향(무방향)그래프 구현
node, edge = map(int, input().split())

graph = [[]*(node) for i in range(node)]

for _ in range(edge):
    m1, m2 = map(int, input().split())
    graph[m1][m2] = graph[m2][m1] = 1
```  
* 인접행렬 장점
  - 구현이 매우 간단
  - 노드끼리의 연결 여부를 확인할 때, graph[i][j]의 값이 1 or 0 인지만 확인하면 되기 때문에 O(N)의 시간 복잡도를 가진다.

* 인접행렬 단점
  - 그래프를 인접행렬로 구현할 경우, 노드의 개수가 간선의 개수보다 많으면 많을수록 탐색을 위해 소요되는 시간이 비효율적으로 증가한다.
  
이러한 단점을 해결하기 위해 착안한 방법이 `인접 리스트`이다.

---

## 2. 인접 리스트
인접리스트란, 각각의 노드에 연결된 노드들을 원소로 갖는 리스트들의 배열을 의미한다.

```buildoutcfg
graph[i]: i번째 노드에 연결된 노드들을 원소로 갖는 리스트
```
* 인접리스트 장점
  - 인접 리스트를 활용하여 그래프의 연결 관계를 저장할 경우, 인접 리스트는 인접 행렬과 달리 실제로 연결된 노드에 대한 정보만 저장하기 때문에, 모든 벡터들의 원소의 개수의 합이 간선의 개수와 동일하다. 즉, 간선의 개수에 비례하는 메모리만 차지하여 구현이 가능하다.
  - 따라서 인접행렬이 갖는 탐색의 비효율성을 인접리스트를 통해 극복이 가능하다.
  
* 인접리스트 단점
  - 노드 i 와 노드 j의 연결 여부를 확인하려면 graph[i]의 리스트를 순회하며 j 원소가 있는지 확인해야 한다. 즉, 인접행렬에 비해 시간복잡도가 크다.
  
* 인접리스트 구현
```python
#간선에 가중치가 없는 무향 그래프 구현
node, edge = map(int, input().split())

graph = [[] for i in range(node)]

for _ in range(edge):
    m1, m2 = map(int, input().split())
    graph[m1].append(m2)
    graph[m2].append(m1)
```  
---

## # 인접행렬 & 인접리스트 요약
- 그래프를 코드로 구현하는 방법은 인접 행렬, 인접 리스트가 있다.
- 인접 행렬: 구현 쉬움, but 간선의 개수에 비해 노드의 개수가 많을 경우 탐색이 비효율적
- 인접 리스트(각 노드에 연결된 노드값만을 원소로 갖는 리스트들의 집합): 인접 행렬이 갖는 단점 극복 가능, but 노드 i와 노드 j의 연결 여부를 확인하려면 노드 i에 연결된 노드들을 하나하나 모두 순회하며 확인해야 한다.
- 각각의 장단점이 있기 때문에 문제 상황에 따라 적절히 사용하는 것이 중요하다.